
/****************************************************************************
* 文 件 名: IRRecod.c
* 作    者: 创思通信
* 修    订: 2015-06-08
* 版    本: V1.0
* 描    述: 红外发送
****************************************************************************

*******************************************************************************/

/*******************************包含头文件*************************************/
#include "IRSend.h"			//红外发送头文件
#include "uart2.h"			//串口头文件
#include "lcd12864.h"		//LCD显示屏头文件
/********************************本地变量**************************************/
#define IRSendPin P0_7
uint16 HWSendAddcode = 0xFF00;
/*******************************************************************************
* 函数名称：IRDelay_10us
* 说    明：红外解码用延时函数 10微秒
* 引用说明：无
* 返    回：无
*******************************************************************************/
void IRSendDelay_10us(uint16 usx10)
{                         
    unsigned int a=0,i=0;
	for(i=0;i<usx10;i++)
	{
		a = 12;
		while(a)
		{
			a--;
		}			
	}
}

/*******************************************************************************
* 函数名称：IRSendInit
* 说    明：IR初始化函数 初始化红外发射头端口 配置38khz载波
* 引用说明：无
* 返    回：无
*******************************************************************************/
void IRSendInit(void)
{
	P0DIR |= 0x80;           //P0.7定义为输出
	P0INP &=  ~0x80;   //打开P01上拉电阻,不影响
	 
	EA = 0;                  //开总中断
	T3CC1 = 0x40; //1S 的占空比   50 A0 198K方波  28 50 395k方波
	T3CC0 = 0x69; //1S的周期时钟    
	T3CCTL0 = 0x1c;  // 模式选择 
	T3CTL = 0x03; //0x03 38khz 
	T3CTL |= 0x10; //启动
	T3CTL |= 0x08 ;          //开溢出中断     
    T3IE = 0;                //开总中断和T3中断
    EA = 1;                  //开总中断
	IRSendPin = 0;
}
/*******************************************************************************
* 函数名称：IR_Sending
* 说    明：IR_Sending红外发送函数
* 引用说明：先调用IRInit初始化
* 返    回：
*******************************************************************************/
uint8 IR_Sending(uint16 IRDat)
{
	uint16 i=0;
	uint8 IRBit = 0;
	
	T3IE = 1;				//打开中断和T3中断
	IRSendPin = 1;	
	IRSendDelay_10us(800);
	T3IE = 0;				//关闭中断和T3中断
	IRSendPin = 1;
	IRSendDelay_10us(450);
	for(i=0;i<16;i++)//发送地址码两个字节 先发低位
	{
		IRBit = (HWSendAddcode>>i)&0x0001;	//取出最低位
		if(IRBit)					//发射逻辑1
		{
			T3IE = 1;				//打开中断和T3中断
			IRSendPin = 1;	
			IRSendDelay_10us(51);
			T3IE = 0;				//关闭中断和T3中断
			IRSendPin = 1;
			IRSendDelay_10us(165);
		}
		else						//发射逻辑0
		{
			T3IE = 1;				//打开中断和T3中断
			IRSendPin = 1;	
			IRSendDelay_10us(51);
			T3IE = 0;				//关闭中断和T3中断
			IRSendPin = 1;
			IRSendDelay_10us(51);					
		}
	}
	for(i=0;i<16;i++)//发送指令码两个字节 先发低位
	{
		IRBit = (IRDat>>i)&0x0001;//取出最低位
		if(IRBit)					//发射逻辑1
		{
			T3IE = 1;				//打开中断和T3中断
			IRSendPin = 1;	
			IRSendDelay_10us(51);
			T3IE = 0;				//关闭中断和T3中断
			IRSendPin = 1;
			IRSendDelay_10us(165);
		}
		else						//发射逻辑0
		{
			T3IE = 1;				//打开中断和T3中断
			IRSendPin = 1;			
			IRSendDelay_10us(51);
			T3IE = 0;				//关闭中断和T3中断
			IRSendPin = 1;
			IRSendDelay_10us(51);					
		}
	}	
	
	T3IE = 1;               
	IRSendPin = 1;			
	IRSendDelay_10us(300);	//协议尾
	T3IE = 0;                
	IRSendPin = 1;			
	return 0;
}
#pragma vector = T3_VECTOR //定时器T3
 __interrupt void T3_ISR(void) 
{ 
	IRCON = 0x00;                  //清中断标志, 也可由硬件自动完成
	IRSendPin=~IRSendPin;  			//中断时发射端口取反，即把38K加载到发射端口上
}
